#ifndef WARTHOG_BCH_BB_EXPANSION_POLICY_H
#define WARTHOG_BCH_BB_EXPANSION_POLICY_H

// contraction/bch_bb_expansion_policy.h
//
// bidirectional contraction hierarchies + bounding boxes
//
// @author: dharabor
// @created: 2016-09-11
//

#include "contraction/contraction.h"
#include "domains/xy_graph.h"
#include "label/dfs_labelling.h"
#include "search/expansion_policy.h"

#include <vector>

namespace warthog{

class bb_filter;
class problem_instance;
class search_node;

class bch_bb_expansion_policy : public  expansion_policy
{
    public:
        // @param backward: when true successors are generated by following 
        // incoming arcs rather than outgoing arcs (default is outgoing)
        // @param filter: the filter used to prune arcs
        bch_bb_expansion_policy(
                warthog::label::dfs_labelling*, 
                bool backward=false);

        virtual 
        ~bch_bb_expansion_policy() { }

		virtual void 
		expand(warthog::search_node*, warthog::problem_instance*);

        virtual void
        get_xy(warthog::sn_id_t node_id, int32_t& x, int32_t& y);

        virtual warthog::search_node* 
        generate_start_node(warthog::problem_instance* pi);

        virtual warthog::search_node*
        generate_target_node(warthog::problem_instance* pi);

        virtual size_t
        mem();

        inline size_t
        get_num_nodes() { return lab_->get_ch_data()->g_->get_num_nodes(); }

    private:
        warthog::label::dfs_labelling* lab_;
        bool backward_;
        int32_t tx_, ty_;

        typedef warthog::graph::edge_iter
                (warthog::bch_bb_expansion_policy::*chep_get_iter_fn) 
                (warthog::graph::node* n);

        // pointers to the neighbours in the direction of the search
        chep_get_iter_fn fn_begin_iter_;
        chep_get_iter_fn fn_end_iter_;

        // pointers to neighbours in the reverse direction to the search
        chep_get_iter_fn fn_rev_begin_iter_;
        chep_get_iter_fn fn_rev_end_iter_;

        inline warthog::graph::edge_iter
        get_fwd_begin_iter(warthog::graph::node* n) 
        { return n->outgoing_begin(); }

        inline warthog::graph::edge_iter
        get_fwd_end_iter(warthog::graph::node* n) 
        { return n->outgoing_end(); }

        inline warthog::graph::edge_iter
        get_bwd_begin_iter(warthog::graph::node* n) 
        { return n->incoming_begin(); }

        inline warthog::graph::edge_iter
        get_bwd_end_iter(warthog::graph::node* n) 
        { return n->incoming_end(); }

        inline bool
        filter_bb_only(uint32_t node_idx, uint32_t edge_idx)
        {
            warthog::label::dfs_label& label = 
                lab_->get_label(node_idx, edge_idx);
            bool retval = label.bbox_.contains(tx_, ty_);
            return !retval; 
        }

        typedef bool
            (warthog::bch_bb_expansion_policy::*chep_filter_fn)
            (uint32_t node_idx, uint32_t edge_idx);

        chep_filter_fn fn_bb_filter_;

        inline bool
        filter_bb_fwd(uint32_t node_idx, uint32_t edge_idx)
        {
            warthog::label::dfs_label& label = 
                lab_->get_label(node_idx, edge_idx);
            bool retval = label.bbox_.contains(tx_, ty_);
            return !retval; 
        }

        inline bool
        filter_bb_bwd(uint32_t node_idx, uint32_t edge_idx)
        { return false; }

};

}
#endif

